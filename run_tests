#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
测试点运行脚本
仅测试 ComplexTestCase-1 到 ComplexTestCase-5 这几组测试用例
"""

import json
import os
import subprocess
import time
import sys
from pathlib import Path

# 配置项
EXECUTABLE = './code'  # 可执行文件路径，根据实际情况修改
CONFIG_FILE = 'testcases/config.json'
TESTCASES_DIR = 'testcases'
OUTPUT_DIR = 'test_output'  # 存储测试输出
DATA_DIR = 'test_data'  # 程序运行时产生数据文件的目录
# 关键配置：指定要测试的目标组列表
TARGET_GROUPS = [
    "ComplexTestCase-1",
    "ComplexTestCase-2",
    "ComplexTestCase-3",
    "ComplexTestCase-4",
    "ComplexTestCase-5"
]

# 颜色输出
class Colors:
    GREEN = '\033[92m'
    RED = '\033[91m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'

def print_colored(text, color):
    """彩色输出"""
    print(f"{color}{text}{Colors.ENDC}")

def clean_data_files():
    """清理程序运行产生的数据文件"""
    import shutil
    # 删除整个数据目录
    if os.path.exists(DATA_DIR):
        try:
            shutil.rmtree(DATA_DIR)
        except Exception as e:
            print(f"警告: 清理数据目录失败: {e}")
    # 重新创建空目录
    os.makedirs(DATA_DIR, exist_ok=True)

def load_config():
    """加载配置文件"""
    with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
        return json.load(f)

def run_single_test(test_point_id, input_file, time_limit_ms=10000):
    """
    运行单个测试点

    Args:
        test_point_id: 测试点编号
        input_file: 输入文件路径
        time_limit_ms: 时间限制（毫秒）

    Returns:
        tuple: (是否成功, 输出内容, 运行时间, 错误信息)
    """
    output_file = os.path.join(OUTPUT_DIR, f'{test_point_id}.out')

    try:
        start_time = time.time()
        with open(input_file, 'r') as fin:
            with open(output_file, 'w') as fout:
                process = subprocess.Popen(
                    [os.path.abspath(EXECUTABLE)],
                    stdin=fin,
                    stdout=fout,
                    stderr=subprocess.PIPE,
                    text=True,
                    cwd=DATA_DIR  # 在数据目录中运行程序
                )

                # 等待进程结束，设置超时
                timeout_sec = time_limit_ms / 1000.0
                try:
                    stderr_output = process.communicate(timeout=timeout_sec)[1]
                    elapsed_time = (time.time() - start_time) * 1000  # 转换为毫秒

                    if process.returncode != 0:
                        return False, None, elapsed_time, f"运行时错误 (返回码: {process.returncode})\n{stderr_output}"

                    with open(output_file, 'r') as f:
                        output = f.read()

                    return True, output, elapsed_time, None

                except subprocess.TimeoutExpired:
                    process.kill()
                    elapsed_time = (time.time() - start_time) * 1000
                    return False, None, elapsed_time, f"超时 (限制: {time_limit_ms}ms)"

    except FileNotFoundError:
        return False, None, 0, f"可执行文件未找到: {EXECUTABLE}"
    except Exception as e:
        return False, None, 0, f"运行错误: {str(e)}"

def compare_output(output, answer_file):
    """
    比对输出和标准答案

    Args:
        output: 程序输出
        answer_file: 标准答案文件路径

    Returns:
        tuple: (是否正确, 差异信息)
    """
    if not os.path.exists(answer_file):
        return None, "标准答案文件不存在"

    with open(answer_file, 'r') as f:
        answer = f.read()

    # 规范化输出（去除行末空格和文件末空行）
    output_lines = [line.rstrip() for line in output.splitlines()]
    answer_lines = [line.rstrip() for line in answer.splitlines()]

    # 去除末尾的空行
    while output_lines and not output_lines[-1]:
        output_lines.pop()
    while answer_lines and not answer_lines[-1]:
        answer_lines.pop()

    if output_lines == answer_lines:
        return True, None

    # 生成差异信息
    diff_info = []
    max_lines = max(len(output_lines), len(answer_lines))
    for i in range(max_lines):
        out_line = output_lines[i] if i < len(output_lines) else "<EOF>"
        ans_line = answer_lines[i] if i < len(answer_lines) else "<EOF>"
        if out_line != ans_line:
            diff_info.append(f"第 {i+1} 行不同:")
            diff_info.append(f"  输出: {out_line}")
            diff_info.append(f"  答案: {ans_line}")
            if len(diff_info) >= 10:  # 只显示前几个差异
                diff_info.append("  ...")
                break

    return False, "\n".join(diff_info)

def run_test_group(group):
    """
    运行一个测试组

    Args:
        group: 测试组配置

    Returns:
        tuple: (通过数, 总数, 详细结果列表)
    """
    group_name = group['GroupName']
    test_points = group['TestPoints']
    group_dir = os.path.join(TESTCASES_DIR, group_name)

    # 每个测试组开始前清理数据文件
    clean_data_files()

    passed = 0
    total = len(test_points)
    results = []

    for idx, point_id in enumerate(test_points, 1):
        input_file = os.path.join(group_dir, f'{point_id}.in')
        answer_file = os.path.join(group_dir, f'{point_id}.out')

        # 实时显示当前运行的测试点
        print(f"  运行测试点 {point_id:3d} ({idx}/{total})...", end='', flush=True)

        if not os.path.exists(input_file):
            print(f" {Colors.YELLOW}跳过{Colors.ENDC}")
            results.append({
                'id': point_id,
                'status': 'SKIP',
                'message': '输入文件不存在',
                'time': 0
            })
            continue  # 继续下一个测试点

        # 运行测试
        success, output, elapsed_time, error = run_single_test(point_id, input_file)

        if not success:
            print(f" {Colors.RED}✗ 错误{Colors.ENDC} ({elapsed_time:.1f}ms)")
            results.append({
                'id': point_id,
                'status': 'ERROR',
                'message': error,
                'time': elapsed_time
            })
        else:
            # 比对结果
            correct, diff = compare_output(output, answer_file)

            if correct is None:
                print(f" {Colors.YELLOW}? 无答案{Colors.ENDC}")
                results.append({
                    'id': point_id,
                    'status': 'NO_ANS',
                    'message': diff,
                    'time': elapsed_time
                })
            elif correct:
                print(f" {Colors.GREEN}✓ 通过{Colors.ENDC} ({elapsed_time:.1f}ms)")
                passed += 1
                results.append({
                    'id': point_id,
                    'status': 'PASS',
                    'message': None,
                    'time': elapsed_time
                })
                # 删除通过的测试点的输出文件
                try:
                    os.remove(os.path.join(OUTPUT_DIR, f'{point_id}.out'))
                except:
                    pass
            else:
                print(f" {Colors.RED}✗ 错误{Colors.ENDC} ({elapsed_time:.1f}ms)")
                results.append({
                    'id': point_id,
                    'status': 'WRONG',
                    'message': diff,
                    'time': elapsed_time
                })
    # 测试组结束后再次清理数据文件
    clean_data_files()

    return passed, total, results

def print_result(result):
    """打印单个测试结果"""
    status = result['status']
    test_id = result['id']
    time_ms = result['time']

    if status == 'PASS':
        print_colored(f"  ✓ 测试点 {test_id:3d}: 通过 ({time_ms:.1f}ms)", Colors.GREEN)
    elif status == 'WRONG':
        print_colored(f"  ✗ 测试点 {test_id:3d}: 答案错误 ({time_ms:.1f}ms)", Colors.RED)
        if result['message']:
            print(f"    {result['message']}")
    elif status == 'ERROR':
        print_colored(f"  ✗ 测试点 {test_id:3d}: {result['message']}", Colors.RED)
    elif status == 'NO_ANS':
        print_colored(f"  ? 测试点 {test_id:3d}: {result['message']}", Colors.YELLOW)
    elif status == 'SKIP':
        print_colored(f"  - 测试点 {test_id:3d}: {result['message']}", Colors.YELLOW)

def main():
    """主函数"""
    print_colored("=" * 60, Colors.CYAN)
    print_colored("Bookstore 测试运行器（仅测试指定复杂测试组）", Colors.BOLD)
    print_colored("=" * 60, Colors.CYAN)
    print()

    # 检查可执行文件
    if not os.path.exists(EXECUTABLE):
        print_colored(f"错误: 找不到可执行文件 {EXECUTABLE}", Colors.RED)
        print("请先编译程序或修改脚本中的 EXECUTABLE 变量")
        sys.exit(1)

    # 创建输出目录和数据目录
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    os.makedirs(DATA_DIR, exist_ok=True)

    # 加载配置
    try:
        config = load_config()
    except Exception as e:
        print_colored(f"错误: 无法加载配置文件: {e}", Colors.RED)
        sys.exit(1)

    # 筛选出目标测试组，并验证存在性
    all_group_names = [g['GroupName'] for g in config['Groups']]
    filtered_groups = []
    missing_groups = []

    for target in TARGET_GROUPS:
        if target in all_group_names:
            # 找到目标组，添加到筛选列表
            filtered_groups.append(next(g for g in config['Groups'] if g['GroupName'] == target))
        else:
            missing_groups.append(target)

    # 若有缺失的组，提示并退出（或可选：仅警告，继续执行存在的组）
    if missing_groups:
        print_colored(f"错误: 配置中未找到以下目标测试组: {', '.join(missing_groups)}", Colors.RED)
        print_colored(f"配置中存在的组名: {', '.join(all_group_names)}", Colors.YELLOW)
        sys.exit(1)

    # 若没有筛选出任何组，提示退出
    if not filtered_groups:
        print_colored("错误: 未筛选到任何目标测试组", Colors.RED)
        sys.exit(1)

    # 运行筛选后的测试组
    total_passed = 0
    total_tests = 0
    total_score = 0
    max_score = 0

    for group_idx, group in enumerate(filtered_groups, 1):
        group_name = group['GroupName']
        group_score = group['GroupScore']
        test_count = len(group['TestPoints'])
        max_score += group_score

        print_colored(f"\n【{group_name}】[{group_idx}/{len(filtered_groups)}] (分值: {group_score}, 测试点: {test_count})", Colors.BLUE)

        passed, total, results = run_test_group(group)
        total_passed += passed
        total_tests += total

        # 打印该组详细结果（只显示错误的测试点）
        has_error = False
        for result in results:
            if result['status'] != 'PASS':
                print_result(result)
                has_error = True

        # 计算该组得分
        if passed == total:
            group_earned = group_score
            print_colored(f"  组得分: {group_earned}/{group_score} ✓ 全部通过!", Colors.GREEN)
            total_score += group_earned
        else:
            # 可选：改为按通过比例得分，如 group_earned = group_score * (passed / total)
            group_earned = 0
            print_colored(f"  组得分: {group_earned}/{group_score} (通过 {passed}/{total})", Colors.RED)

    # 打印总结
    print_colored("\n" + "=" * 60, Colors.CYAN)
    print_colored("测试总结（仅指定复杂测试组）", Colors.BOLD)
    print_colored("=" * 60, Colors.CYAN)
    if total_tests == 0:
        print("未执行任何测试点")
    else:
        print(f"通过测试点: {total_passed}/{total_tests}")
        print(f"总得分: {total_score}/{max_score}")
        accuracy = (total_passed / total_tests * 100) if total_tests > 0 else 0
        print(f"正确率: {accuracy:.2f}%")
    print_colored("=" * 60, Colors.CYAN)

    # 清理test_data文件夹
    import shutil
    if os.path.exists(DATA_DIR):
        try:
            shutil.rmtree(DATA_DIR)
            print(f"\n已清理数据目录: {DATA_DIR}")
        except Exception as e:
            print(f"\n警告: 清理数据目录失败: {e}")

    # 返回状态码
    sys.exit(0 if total_passed == total_tests and total_tests > 0 else 1)

if __name__ == '__main__':
    main()